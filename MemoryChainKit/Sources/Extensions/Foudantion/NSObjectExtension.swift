//
//  NSObjectExtension.swift
//  MemoryChainKit
//
//  Created by Marc Zhao on 2020/3/10.
//  Copyright Â© 2020 Marc Zhao(https://github.com/MarcSteven). All rights reserved.
//

import Foundation


extension NSObject {
    //MARK: - private type
    private struct Static {
        static var performWhileIgnoringObservationsKey = "performWhileIgnoringObservationsKey"
    }
    //MARK: - public method
    public func performWhileIgnoringObservations(_ observations:[KeyValueObservationInfo],
                                                 completion:() throws ->Void) rethrows {
        if observations.isEmpty {
            try completion()
            return
        }
        let superObserveValueForKeyPath = self.superclass != nil ? class_getInstanceMethod(self.superclass, #selector(NSObject.observeValue(forKeyPath:of:change:context:))) : nil
        var observeValueForKeyPath = class_getInstanceMethod(type(of: self), #selector(NSObject.observeValue(forKeyPath:of:change:context:)))!
        if observeValueForKeyPath == superObserveValueForKeyPath {
                   // 'self' doesn't override NSObject.observeValue(forKeyPath:of:change:context:). We should
                   // add this method to 'self' so that we don't replace the global implementation of
                   // NSObject.observeValue(forKeyPath:of:change:context:) with our custom handler.
                   
                   class_addMethod(type(of: self), method_getName(superObserveValueForKeyPath!), method_getImplementation(superObserveValueForKeyPath!), method_getTypeEncoding(superObserveValueForKeyPath!))
                   observeValueForKeyPath = class_getInstanceMethod(type(of: self), method_getName(superObserveValueForKeyPath!))!
               }
               
               let originalObserveValueForKeyPath = method_getImplementation(observeValueForKeyPath)
               
               unowned let __unowned = self
               let __observeValueForKeyPath = { (_self: AnyObject, _keyPath: String?, _object: Any?, _change: [NSKeyValueChangeKey : Any]?, _context: UnsafeMutableRawPointer?) -> Void in
                   for observation in observations {
                       if __unowned === _self && (observation.observed == nil || observation.observed === (_object as! NSObject?)) && (observation.keyPath == nil || observation.keyPath == _keyPath) {
                           return // Ignore
                       }
                   }
                   
                   unsafeBitCast(originalObserveValueForKeyPath, to: (@convention(c) (AnyObject, Selector, String?, Any?, [NSKeyValueChangeKey : Any]?, UnsafeMutableRawPointer?) -> Void).self)(_self, #selector(NSObject.observeValue(forKeyPath:of:change:context:)), _keyPath, _object, _change, _context)
               }
               
               objc_setAssociatedObject(self, &Static.performWhileIgnoringObservationsKey, __observeValueForKeyPath, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
               let replacementObserveValueForKeyPath = class_getInstanceMethod(NSObject.self, #selector(NSObject.__replacementObserveValue(forKeyPath:of:change:context:)))!
               method_setImplementation(observeValueForKeyPath, method_getImplementation(replacementObserveValueForKeyPath))
               
               defer {
                   // Always set back original implementation and remove the associated object
                   method_setImplementation(observeValueForKeyPath, originalObserveValueForKeyPath)
                   objc_setAssociatedObject(self, &Static.performWhileIgnoringObservationsKey, nil, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
               }
               
               try completion()
           }
           
           @objc private func __replacementObserveValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
               (objc_getAssociatedObject(self, &Static.performWhileIgnoringObservationsKey) as! (AnyObject, String?, Any?, [NSKeyValueChangeKey : Any]?, UnsafeMutableRawPointer?) -> Void)(self, keyPath, object, change, context)
           }
           
           
           
           func addObserver(for keyPath: String, options: NSKeyValueObservingOptions, handler: @escaping (NSObject, String, [NSKeyValueChangeKey : Any]?) -> Void) -> NSObject {
               return KeyValueObservationProxy(observed: self, keyPath: keyPath, options: options, handler: handler)
           }
           
           func removeObserver(with context: NSObject) {
               guard let context = context as? KeyValueObservationProxy else {
                   fatalError("Invalid context object. The context must have been generated by a call to \(NSStringFromClass(type(of: self))).addObserver(for:options:handler:)")
               }
               
               self.removeObserver(context, forKeyPath: context.keyPath, context: nil)
               context.observed = nil
               context.keyPath  = nil
               context.handler  = nil
           }
    }



// use generic to associated different type property
public extension NSObject {
    func setAssociated<T>(value:T,associatedKey:UnsafeRawPointer,
                          policy:objc_AssociationPolicy = objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) {
        objc_setAssociatedObject(self, associatedKey, value, policy)
    }
    func getAssociated<T>(associatedKey:UnsafeRawPointer) ->T? {
        let value = objc_getAssociatedObject(self, associatedKey) as? T
        return value
    }
}
public extension NSObject {
    var memoryAddress: String {
        String(describing: Unmanaged<NSObject>.passUnretained(self).toOpaque())
    }
}

extension NSObject {
    /// Returns the value for the property identified by a given key.
    ///
    /// The search pattern that `valueForKey:` uses to find the correct value
    /// to return is described in **Accessor Search Patterns** in **Key-Value Coding Programming Guide**.
    ///
    /// - Parameter key: The name of one of the receiver's properties.
    /// - Returns: The value for the property identified by key.
    open func safeValue(forKey key: String) -> Any? {
        let mirror = Mirror(reflecting: self)

        for child in mirror.children.makeIterator() where child.label == key {
            return child.value
        }

        return nil
    }

    /// Return `true` if the `self` has the property of given `name`; otherwise, `false`.
    open func hasProperty(withName name: String) -> Bool {
        safeValue(forKey: name) != nil
    }
}

// MARK: LookupComparison

extension NSObject {
    public enum LookupComparison {
        /// Indicates whether the receiver is an instance of given class or an
        /// instance of any class that inherits from that class.
        case kindOf

        /// The dynamic type.
        case typeOf
    }

    /// - Parameters:
    ///   - aClass: A class object representing the Objective-C class to be tested.
    ///   - comparison: The comparison option to use when comparing `self` to `aClass`.
    ///
    /// - Returns: When option is `.kindOf` then this method returns true if `aClass` is a Class object of the same type.
    ///            Otherwise, `.typeOf` does direct check to ensure `aClass` is the same object and not a subclass.
    public func isType(of aClass: Swift.AnyClass, comparison: LookupComparison) -> Bool {
        switch comparison {
            case .kindOf:
                return isKind(of: aClass)
            case .typeOf:
                return aClass.self == type(of: self)
        }
    }
}

// MARK: Property List


